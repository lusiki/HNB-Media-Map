slice_max(order_by = total_freq, n = 1, with_ties = FALSE) %>%
ungroup() %>%
select(doc_id, dominant_emotion = emotion)
# --- 3.4: Izračun Indeksa Konflikta (CLI i RCI) za financijske teme ---
conflict_lexicon <- unique(c(
(nrc_lexicon_long %>% filter(emotion %in% c("Ljutnja", "Gađenje", "Strah")) %>% pull(word)),
(crosentilex_full %>% filter(sentiment_value <= -0.75) %>% pull(word)),
c("kriza", "kolaps", "neuspjeh", "pogreška", "kritika", "neodgovorno", "rizično", "zabrinjavajuće", "nestabilno", "problematično", "kontroverzno", "sporno", "sumnjivo", "loš", "katastrofal", "kaotičan", "recesija", "inflacija", "deflacija", "bankrot")
))
cli_scores <- lemmatized_words_with_freq %>%
mutate(is_conflict = lemma %in% conflict_lexicon) %>%
group_by(doc_id) %>%
summarise(
total_words = sum(word_frequency),
conflict_words = sum(word_frequency[is_conflict])
) %>%
mutate(cli = (conflict_words / total_words) * 1000) %>% ungroup()
dta_temp <- dta_enriched %>%
left_join(document_sentiments_gold, by = "doc_id") %>%
left_join(document_emotions, by = "doc_id") %>%
left_join(cli_scores %>% select(doc_id, cli), by = "doc_id") %>%
mutate(
sentiment_score = ifelse(is.na(sentiment_score_gold), 0, sentiment_score_gold),
dominant_emotion = ifelse(is.na(dominant_emotion), "Neutralno", dominant_emotion),
cli = ifelse(is.na(cli), 0, cli)
)
avg_cli_media <- dta_temp %>% group_by(FROM) %>% summarise(avg_cli_media = mean(cli))
avg_cli_topic <- dta_temp %>% group_by(dominant_topic) %>% summarise(avg_cli_topic = mean(cli))
dta_final <- dta_temp %>%
left_join(avg_cli_media, by = "FROM") %>%
left_join(avg_cli_topic, by = "dominant_topic") %>%
mutate(
expected_cli = 0.5 * avg_cli_media + 0.5 * avg_cli_topic,
rci = cli - expected_cli
)
# --- KOD ZA DETEKCIJU ANOMALIJA (POBOLJŠANA VERZIJA) ---
daily_summary <- dta_final %>%
mutate(date = as.Date(DATE)) %>%
group_by(date) %>%
summarise(
n_articles = n(),
avg_cli = mean(cli, na.rm = TRUE)
) %>%
ungroup()
# Računamo pragove (99-i percentil)
volume_threshold <- quantile(daily_summary$n_articles, 0.99)
cli_threshold <- quantile(daily_summary$avg_cli, 0.99)
# Identificiramo "potrese"
spikes_detected <- daily_summary %>%
mutate(
is_volume_spike = n_articles > volume_threshold,
is_cli_spike = avg_cli > cli_threshold
)
# Vizualizacija
p_volume <- ggplot(spikes_detected, aes(x = date, y = n_articles)) +
geom_line(color = "grey") +
geom_point(data = filter(spikes_detected, is_volume_spike), color = "red", size = 3) +
geom_hline(yintercept = volume_threshold, linetype="dashed", color="red") +
theme_minimal() +
labs(title = "Ekstremni volumen objava", y = "Broj članaka dnevno", x = "")
p_cli <- ggplot(spikes_detected, aes(x = date, y = avg_cli)) +
geom_line(color = "grey") +
geom_point(data = filter(spikes_detected, is_cli_spike), color = "red", size = 3) +
geom_hline(yintercept = cli_threshold, linetype="dashed", color="red") +
theme_minimal() +
labs(title = "Ekstremni intenzitet konflikta", y = "Prosječni CLI dnevno", x = "Datum")
#p_volume / p_cli
# --- KOD ZA STANDARDIZIRANU DETEKCIJU ANOMALIJA ---
# Agregiramo podatke po danu
daily_summary <- dta_final %>%
mutate(date = as.Date(DATE),
year = year(date)) %>% # Dodajemo godinu za godišnju standardizaciju
group_by(date, year) %>%
summarise(
n_articles = n(),
avg_cli = mean(cli, na.rm = TRUE),
.groups = "drop"
)
# Standardiziramo vrijednosti (računamo Z-score) unutar svake godine
standardized_summary <- daily_summary %>%
group_by(year) %>%
mutate(
# Z-score = (vrijednost - prosjek) / standardna devijacija
z_score_volume = (n_articles - mean(n_articles)) / sd(n_articles),
z_score_cli = (avg_cli - mean(avg_cli)) / sd(avg_cli)
) %>%
ungroup()
# Definiramo prag za "šiljak" (npr. 3 standardne devijacije)
spike_threshold_z <- 3
# Identificiramo "potrese"
spikes_detected_z <- standardized_summary %>%
mutate(
is_volume_spike = z_score_volume > spike_threshold_z,
is_cli_spike = z_score_cli > spike_threshold_z
)
# --- ISPIS DATUMA S ANOMALIJAMA ---
volume_spike_dates <- spikes_detected_z %>%
filter(is_volume_spike) %>%
select(date, n_articles, z_score_volume) %>%
arrange(desc(z_score_volume))
cli_spike_dates <- spikes_detected_z %>%
filter(is_cli_spike) %>%
select(date, avg_cli, z_score_cli) %>%
arrange(desc(z_score_cli))
# # (Ovaj dio ispod će ispisati tablice direktno u vaš HTML dokument)
# cat("### Dani s Ekstremnim Volumom Objava\n\n")
# knitr::kable(volume_spike_dates, caption = "Top datumi rangirani po Z-scoreu volumena.")
#
# cat("\n### Dani s Ekstremnim Intenzitetom Konflikta\n\n")
# knitr::kable(cli_spike_dates, caption = "Top datumi rangirani po Z-scoreu konflikta.")
# --- VIZUALIZACIJA STANDARDIZIRANIH VRIJEDNOSTI ---
p_volume_z <- ggplot(spikes_detected_z, aes(x = date, y = z_score_volume)) +
geom_line(color = "grey") +
geom_point(data = filter(spikes_detected_z, is_volume_spike), color = "red", size = 3) +
geom_hline(yintercept = spike_threshold_z, linetype = "dashed", color = "red") +
theme_minimal() +
labs(
title = "Anomalije u volumenu objava (Standardizirano)",
y = "Odstupanje od prosjeka (u st. dev.)",
x = ""
)
p_cli_z <- ggplot(spikes_detected_z, aes(x = date, y = z_score_cli)) +
geom_line(color = "grey") +
geom_point(data = filter(spikes_detected_z, is_cli_spike), color = "red", size = 3) +
geom_hline(yintercept = spike_threshold_z, linetype = "dashed", color = "red") +
theme_minimal() +
labs(
title = "Anomalije u intenzitetu konflikta (Standardizirano)",
y = "Odstupanje od prosjeka (u st. dev.)",
x = "Datum"
)
p_volume_z
p_cli_z
dbDisconnect(con)
# Load necessary packages for the presentation
library(scales)#
#library(patchwork)
library(ggrepel)
library(udpipe)
library(dplyr)
library(tidytext)
library(stringr)
library(ggplot2)
library(forcats)
library(tidyr)
library(ggridges)
library(widyr)
library(ggraph)
library(igraph)
library(wordcloud)
library(RColorBrewer)
library(tidyverse)
library(lubridate)
library(data.table)
library(readxl)
library(plotly)
library(patchwork)
# --- 0. SETUP (This should already be in your setup chunk) ---
platform_color_mapping <- c(
"web"       = "#003366",  # HNB Dark Blue
"facebook"  = "#5B9BD5",  # HNB Medium Blue
"comment"   = "#C00000",  # HNB Accent Red
"twitter"   = "#BF8F00",  # HNB Accent Gold
"forum"     = "#005F56",  # HNB Dark Green
"youtube"   = "#7F7F7F",  # HNB Medium Grey
"reddit"    = "#A0522D"
)
# theme_hnb <- theme_minimal(base_size = 14, base_family = "Roboto Mono") +
#   theme(
#     plot.title = element_text(face = "bold", size = 16, color = hnb_colors["dark_blue"]),
#     plot.subtitle = element_text(size = 12, color = hnb_colors["medium_grey"]),
#     legend.position = "top"
#   )
# theme_set(theme_hnb)
# --- 1. PREPARE THE COLOR MAPPING ---
# Create the named vector that explicitly tells ggplot which color to use for which platform.
# This is the crucial step you were missing.
# Učitavanje potrebnih paketa
required_packages <- c(
"duckdb",       # Za efikasno upravljanje podacima slično bazi podataka
"dplyr",        # Za manipulaciju podacima
"ggplot2",      # Za vizualizacije
"lubridate",    # Za rad s datumima i vremenom
"scales",       # Za formatiranje brojeva u vizualizacijama
"knitr",        # Za kable tablice
"RColorBrewer", # Za palete boja
"stringr",      # Za manipulaciju tekstom
"tidyr",        # Za pivotiranje podataka za vizualizacije
"ggrepel",      # Za izbjegavanje preklapanja teksta na grafikonima
"fmsb",
"kableExtra"
)
for (pkg in required_packages) {
# Ovdje pretpostavljamo da su svi paketi instalirani
library(pkg, character.only = TRUE)
}
# --- Povezivanje s DuckDB bazom podataka ---
# VAŽNO: Prilagodite putanju do vaše .duckdb datoteke!
duckdb_file_path <- "C:/Users/lukas/Determbaza/DetermDB/determDB.duckdb" # <--- PRILAGODITE OVO!
table_name <- "media_data"
if (!file.exists(duckdb_file_path)) {
stop("DuckDB datoteka nije pronađena na navedenoj putanji: ", duckdb_file_path,
"\nMolimo provjerite putanju ili pokrenite skriptu za učitavanje XLSX datoteka.")
}
con <- dbConnect(duckdb::duckdb(), dbdir = duckdb_file_path, read_only = FALSE)
message("Povezano s perzistentnom DuckDB bazom za analizu.")
l <- dbExecute(con, "SET memory_limit='16GB';") # Održavanje memorijskog limita
# --- Provjera statusa tablice i broja objava ---
# Ispravka za izvlačenje numeričke vrijednosti iz data.frame-a
count_result <- dbGetQuery(con, paste0("SELECT COUNT(*) FROM ", table_name, ";"))[[1]]
# --- 2. Dominacija platformi i njihove napredne performanse (Udio, Učinkovitost i Interakcijski Profil) ---
platform_overview_ultimate <- dbGetQuery(con, paste0("
SELECT
SOURCE_TYPE,
COUNT(*) AS num_posts,
SUM(INTERACTIONS) AS total_interactions,
SUM(REACH) AS total_reach,
AVG(INTERACTIONS) AS avg_interactions_per_post,
AVG(REACH) AS avg_reach_per_post,
AVG(ENGAGEMENT_RATE) AS platform_avg_engagement_rate,
AVG(VIRALITY) AS platform_avg_virality,
(SUM(SHARE_COUNT) * 1.0 / NULLIF(SUM(INTERACTIONS), 0)) * 100 AS platform_shareability_index,
(SUM(LIKE_COUNT) * 1.0 / NULLIF(SUM(INTERACTIONS), 0)) * 100 AS platform_like_ratio,
(SUM(COMMENT_COUNT) * 1.0 / NULLIF(SUM(INTERACTIONS), 0)) * 100 AS platform_comment_ratio
FROM ", table_name, "
GROUP BY SOURCE_TYPE
ORDER BY num_posts DESC;
")) %>%
mutate(across(c(platform_avg_engagement_rate, platform_avg_virality, platform_shareability_index, platform_like_ratio, platform_comment_ratio),
~ifelse(is.nan(.), 0, .))) # Handle potential NaN for display
# Vizualizacija 1: Ukupan broj objava po platformi (General Overview - Posts per Platform)
ggplot(
platform_overview_ultimate,
# Modern syntax for horizontal bars: y-axis is the category, x-axis is the value
aes(x = num_posts, y = reorder(SOURCE_TYPE, num_posts), fill = SOURCE_TYPE)
) +
# geom_col() is the modern replacement for geom_bar(stat="identity")
geom_col() +
# Add formatted text labels that match the plot's font
geom_text(
aes(label = scales::comma(num_posts, accuracy = 1)),
hjust = -0.1,
size = 3.5,
family = "Roboto Mono" # Ensures font consistency with the global theme
) +
# THE FIX: Apply your custom color mapping
scale_fill_manual(values = platform_color_mapping) +
# Format the x-axis and add space for labels
scale_x_continuous(
labels = scales::comma,
expand = expansion(mult = c(0.01, 0.15))
) +
# Remove the redundant legend
guides(fill = "none") +
# Add clearer, more professional titles
labs(
title = "Ukupan broj objava po platformi",
subtitle = "",
x = "Broj objava",
y = "Tip platforme"
) +
# Final theme tweaks for a cleaner look
theme(
panel.grid.major.y = element_blank(), # Remove horizontal grid lines for focus
panel.grid.minor.x = element_blank()
)
# Load necessary packages for the presentation
library(scales)#
#library(patchwork)
library(ggrepel)
library(udpipe)
library(dplyr)
library(tidytext)
library(stringr)
library(ggplot2)
library(forcats)
library(tidyr)
library(ggridges)
library(widyr)
library(ggraph)
library(igraph)
library(wordcloud)
library(RColorBrewer)
library(tidyverse)
library(lubridate)
library(data.table)
library(readxl)
library(plotly)
library(patchwork)
# --- 0. SETUP (This should already be in your setup chunk) ---
platform_color_mapping <- c(
"web"       = "#003366",  # HNB Dark Blue
"facebook"  = "#5B9BD5",  # HNB Medium Blue
"comment"   = "#C00000",  # HNB Accent Red
"twitter"   = "#BF8F00",  # HNB Accent Gold
"forum"     = "#005F56",  # HNB Dark Green
"youtube"   = "#7F7F7F",  # HNB Medium Grey
"reddit"    = "#A0522D"
)
# theme_hnb <- theme_minimal(base_size = 14, base_family = "Roboto Mono") +
#   theme(
#     plot.title = element_text(face = "bold", size = 16, color = hnb_colors["dark_blue"]),
#     plot.subtitle = element_text(size = 12, color = hnb_colors["medium_grey"]),
#     legend.position = "top"
#   )
# theme_set(theme_hnb)
# --- 1. PREPARE THE COLOR MAPPING ---
# Create the named vector that explicitly tells ggplot which color to use for which platform.
# This is the crucial step you were missing.
library(duckdb)
library(dplyr)
library(ggplot2)
library(lubridate)
library(scales)
library(tidyr)
library(eurostat)
# IMPORTANT: Adjust the path to your .duckdb file!
duckdb_file_path <- "C:/Users/lukas/Determbaza/DetermDB/determDB.duckdb" # <--- ADJUST THIS!
table_name <- "media_data"
# Establish connection to the database
con <- dbConnect(duckdb::duckdb(), dbdir = duckdb_file_path, read_only = TRUE)
dbExecute(con, "SET memory_limit='16GB';")
# --- 1. SETUP: Define Keyword Dictionaries ---
# These lists are based on the provided table and use word stems for broader matching.
economy_terms <- c(
"ekonom", "gospodarstv", "financij", "proračun", "bdp",
"bruto domaći proizvod", "poduzeć", "tvrtk", "tržišt",
"dionic", "kamatn", "stop"
)
policy_terms <- c(
"politik", "vlada", " sabor", "ministarstv", "regulativ", "zakon",
"uredb", "hnb", "narodna banka", "fina", "porez", "carin",
"deficit", "javni dug"
)
uncertainty_terms <- c(
"nesigurn", "neizvjesn", "rizik", "prijetnj", "nestabiln",
"neodređen", "dvojb", "zabrinut"
)
# --- 2. DYNAMIC SQL QUERY CONSTRUCTION ---
# This approach programmatically builds the complex search conditions,
# which is much more robust and readable than a single, massive SQL string.
# We'll search a concatenated and lowercased version of TITLE and FULL_TEXT
search_column <- "LOWER(TITLE || ' ' || FULL_TEXT)"
# Function to create a SQL 'OR' chain for a list of terms
create_sql_condition <- function(terms, column) {
conditions <- paste0(sprintf("%s LIKE '%%%s%%'", column, terms), collapse = " OR ")
return(paste0("(", conditions, ")"))
}
# Create the condition for each category
e_condition <- create_sql_condition(economy_terms, search_column)
p_condition <- create_sql_condition(policy_terms, search_column)
u_condition <- create_sql_condition(uncertainty_terms, search_column)
# --- 3. DATA RETRIEVAL ---
# This query counts both the total number of web articles and the number of articles
# matching all three (E, P, and U) criteria, aggregated by month.
sql_query_epu <- sprintf("
SELECT
STRFTIME(DATETIME, '%%Y-%%m') AS year_month,
COUNT(*) AS total_articles,
SUM(CASE
WHEN (%s) AND (%s) AND (%s)
THEN 1
ELSE 0
END) AS epu_articles
FROM %s
WHERE SOURCE_TYPE = 'web'
GROUP BY year_month
ORDER BY year_month;
", e_condition, p_condition, u_condition, table_name)
cat("Executing EPU query... This may take some time depending on database size.\n")
epu_counts <- dbGetQuery(con, sql_query_epu)
cat("Data successfully retrieved.\n")
# --- 4. INDEX CALCULATION ---
# This section follows the Baker, Bloom, and Davis methodology for scaling and standardization.
epu_index_data <- epu_counts %>%
# Ensure there are no months with zero total articles to avoid division by zero
filter(total_articles > 0) %>%
mutate(
# Step 1: Scale the monthly EPU count by the total number of articles that month
scaled_freq = epu_articles / total_articles,
# Step 2: Standardize the resulting series to have a mean of 100
# This makes the index easily comparable over time.
epu_index = (scaled_freq / mean(scaled_freq, na.rm = TRUE)) * 100,
# Create a date column for plotting
month_date = ymd(paste0(year_month, "-01"))
) %>%
# Filter to the main period of analysis for a stable index
filter(year(month_date) >= 2021 & year(month_date) <= 2024)
cat("EPU Index calculated successfully.\n")
# --- 5. VISUALIZATION ---
ggplot(epu_index_data, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
annotate("text", x = max(epu_index_data$month_date), y = 105, label = "Prosjek = 100",
hjust = 1, color = "#C00000", fontface = "italic") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU) za Hrvatsku",
[cite_start]subtitle = "Na temelju metodologije Baker, Bloom i Davis (2016) i medijskih objava [cite: 1, 2, 3, 4]",
x = "Mjesec i godina",
y = "Vrijednost EPU indeksa (Prosjek = 100)"
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 12, color = "gray30")
)
# --- 5. VISUALIZATION ---
ggplot(epu_index_data, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
annotate("text", x = max(epu_index_data$month_date), y = 105, label = "Prosjek = 100",
hjust = 1, color = "#C00000", fontface = "italic") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU) za Hrvatsku",
[cite_start]subtitle = "Na temelju metodologije Baker, Bloom i Davis (2016) i medijskih objava [cite: 1, 2, 3, 4]",
x = "Mjesec i godina",
y = "Vrijednost EPU indeksa (Prosjek = 100)"
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 18),
plot.subtitle = element_text(size = 12, color = "gray30")
)
# --- 5. VISUALIZATION ---
ggplot(epu_index_data, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
annotate("text", x = max(epu_index_data$month_date), y = 105, label = "Prosjek = 100",
hjust = 1, color = "#C00000", fontface = "italic") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU) za Hrvatsku",
subtitle = "Na temelju metodologije Baker, Bloom i Davis (2016) i medijskih objava",
x = "Mjesec i godina",
y = "Vrijednost EPU indeksa (Prosjek = 100)"
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12, color = "gray30")
)
# --- 5. VISUALIZATION ---
epu_index_2024 <- epu_index_data %>%
filter(year(month_date) == 2024)
# --- Create the Plot ---
ggplot(epu_index_2024, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1.2) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU) za 2024.",
subtitle = "Vrijednosti indeksa u odnosu na povijesni prosjek (100)",
x = "Mjesec",
y = "Vrijednost EPU indeksa"
) +
# Adjust x-axis to show months for a single-year view
scale_x_date(
date_breaks = "2 months",
date_labels = "%B" # Shows the full month name
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12, color = "gray30")
)
# --- 5. VISUALIZATION ---
epu_index_filtered <- epu_index_data %>%
filter(month_date <= ymd("2024-01-31"))
# --- Create the Plot ---
ggplot(epu_index_filtered, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1.2) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU)",
subtitle = "Podaci za razdoblje 2021. - siječanj 2024.",
x = "Godina",
y = "Vrijednost EPU indeksa (Prosjek = 100)"
) +
# Adjust x-axis for a multi-year view
scale_x_date(
date_breaks = "6 months",
date_labels = "%b %Y" # e.g., "Sij 2024"
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12, color = "gray30"),
axis.text.x = element_text(angle = 45, hjust = 1) # Angle labels for better fit
)
# --- 5. VISUALIZATION ---
epu_index_filtered <- epu_index_data %>%
filter(month_date <= ymd("2023-12-31"))
# --- Create the Plot ---
ggplot(epu_index_filtered, aes(x = month_date, y = epu_index)) +
geom_line(color = "#003366", linewidth = 1.2) +
geom_hline(yintercept = 100, linetype = "dashed", color = "#C00000") +
labs(
title = "Indeks ekonomske i političke nesigurnosti (EPU)",
subtitle = "Podaci za razdoblje 2021. - siječanj 2024.",
x = "Godina",
y = "Vrijednost EPU indeksa (Prosjek = 100)"
) +
# Adjust x-axis for a multi-year view
scale_x_date(
date_breaks = "6 months",
date_labels = "%b %Y" # e.g., "Sij 2024"
) +
theme_minimal(base_family = "sans") +
theme(
plot.title = element_text(face = "bold", size = 16),
plot.subtitle = element_text(size = 12, color = "gray30"),
axis.text.x = element_text(angle = 45, hjust = 1) # Angle labels for better fit
)
dbDisconnect(con)
